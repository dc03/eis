TYPE           ::= ("const")? ("ref")? "int" | "float" | "string" ;
IDENTIFIER     ::= ("A"..."Z" | "a"..."z" | "_") ("0"..."9" | "A"..."Z" | "a"..."z" | "_")* ;
ANY_TYPE       ::= (TYPE | ("const")? ("ref")? IDENTIFIER) ;
STRING         ::= "\'" ("A"..."Z" | "a"..."z" | "\n" | "\r" | "\t" | "\b" | "\\")+  "\'"
                 | "\"" ("A"..."Z" | "a"..."z" | "\n" | "\r" | "\t" | "\b" | "\\")+  "\"" ;
NUMBER         ::= ("0"..."9" | "'")* "."? ("0"..."9" | "'")+ ("e" ("0"..."9" | "'")+)? ;

program        ::= declaration* EOF;

expression     ::= assignment;
assignment     ::= (call ".")? IDENTIFIER ("=" | "+=" | "-=" | "*=" | "/=") assignment
                 | comma;
comma          ::= ternary ((",") ternary)* ;
ternary        ::= bit_or ("?" bit_or ":" ternary)* ;
bitor          ::= bit_xor ("|" bit_xor)* ;
bitxor         ::= bit_and ("^" bit_and)* ;
bitand         ::= equality ("&" equality)* ;
logic_or       ::= logic_and (("or" | "||") logic_and)* ;
logic_and      ::= equality (("and" | "&&") equality)* ;
equality       ::= comparison (("!=" | "==") comparison)* ;
comparison     ::= bitshift ((">" | ">=" | "<" | "<=") bitshift)* ;
bitshift       ::= addition (("<<" | ">>") addition)* ;
addition       ::= multiplication (("-" | "+" | "%") multiplication)* ;
multiplication ::= unary (("/" | "*") unary)* ;
unary          ::= ("!" | "-" | "~" | "++" | "--") unary
                 | call ;
call           ::= primary ("(" arguments? ")" | "." IDENTIFIER)* ;
arguments      ::= expression ("," expression)* ;
primary        ::= "false" | "true" | "null"
                 | NUMBER | STRING | IDENTIFIER | IDENTIFIER "[" expression "]"
                 | "typeof" IDENTIFIER
                 | "(" expression ")" ;

declaration    ::= statement
                 | import
                 | varDecl
                 | funcDecl
                 | typeDecl
                 | classDecl ;

statement      ::= exprStmt
                 | forStmt
                 | ifStmt
                 | whileStmt
                 | switchStmt
                 | breakStmt
                 | continueStmt
                 | returnStmt
                 | block ;

import         ::= "import" IDENTIFIER (";"|"\n");

varDecl        ::= ("var" | "val") IDENTIFIER ((":" (ANY_TYPE | "[" ANY_TYPE "," NUMBER "]"))? "=" expression)? (";"|"\n");

funcDecl       ::= "fn" "(" arguments? ")" "->" ANY_TYPE "{" body "}" ;
template_args  ::= (IDENTIFIER ",")* IDENTIFIER ;
arguments      ::= (IDENTIFIER ":" ANY_TYPE)* ;
body           ::= (varDecl | statement)* ;

typeDecl       ::= "type" IDENTIFIER "=" ANY_TYPE (";"|"\n") ;
classDecl      ::= "class" IDENTIFIER "{" (("private" | "public" | "protected") (varDecl | funcDecl))* "}" ;


exprStmt       ::= expression (";"|"\n");
forStmt        ::= "for" "(" ( varDecl | exprStmt | ";" ) expression? ";" expression? ")" statement ;
ifStmt         ::= "if" expression statement ( "else" statement )? ;
whileStmt      ::= "while" expression statement ;
switchStmt     ::= "switch" expression "{" ("case" expression ":" statement)* ("default" ":" expression)? "}" ;
breakStmt      ::= "break" (";"|"\n") ;
continueStmt   ::= "continue" (";"|"\n");
returnStmt     ::= "return" expression? (";"|"\n") ;
block          ::= "{" ( varDecl | statement )* "}" ;
