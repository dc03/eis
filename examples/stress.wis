/*/*/*
"This is a multiline\n
\t\b\b\b\b\\\\string"
// @#$

(5 + 6 - 4 + 3 * (5 - 6))
++(5 + 6)
x + 6



5 + 6



5, 6, 7
array.foo.sf(bar,
             baz,
             (quux[
             5]
             )

            )

x = 5
x += 5
x -= 5
x *= 5
x /= 5
x, y, z
x, y = 5, z = 6
x ? y : z
!!x
~~x
++x
--x
x.y.z = 5
x.y.z += 5
x.y.z -= 5
x.y.z *= 5
x.y.z /= 5
x.y.z, a.b.c, e.d.f
x.y.z ? a.b.c : e.d.f
!!x.y.z
~~x.y.z
++x.y.z
--x.y.z
x.y.z(5, 6, 7, arr[foo])

import foo
// */*/*/

var x: int = 5
val y: int = 5

fn bar(x: int, y: string) -> Foo {
    print("Hello world")
    return Foo(5)
}

// type Bar = Baz
class StructA {
    public var x: int
    public fn StructA() -> StructA {
        this.x = 5
    }
    public fn ~StructA() -> null {
    }
}

for (var i: int = 0; i < 5; ++i) {
    break
    continue
    print("hello world")
}

if 5 == 6 {
    print("How")
} else if 5 != 6 {
    print("Yes")
}

while x < 5 {
    print(x)
    ++x
}

switch (x) {
    case 5: {
        print(x)
        break
    }
    case 6: {
        print(x + 1)
        break
    }
    default: {
        print("Default case")
        break
    }
}

fn foo(x: int) -> int {
    return x
}

for (var i: int = 0; i < 5; ++i) {
    break
    continue
}

 
{
    print("Hello world");
}

// break
// class F }
// fn bar(x:) -> }
var goo = 4;
switch (goo) {
    case goo: break
}
// */*/*/

import "../examples/imported.eis"

class Bar {
    public var x: int
}

class Foo {
    public var y: Bar

    public fn xi(z: int) -> int {
        return this.y.x * z
    }

    public fn Foo(x: int) -> Foo {
        var new: Foo
        return new
    }
}

fn test() -> [int] {
    var x: [int]
    return x
}

var y = 0.5
test2(y)
fn test2(x: int) -> int {
    var y: const ref int = x
    return y
}

var foo = Foo(5)
var z: [[int, foo], 5]
var zzy: int = 5, 6,
z[0][0]

var yay = imported::X()
print(yay.x)
print(imported::foo())

import "imported.eis"

var y = imported::X()
y.x = 6

for (var i = 0; i < 5; ++i) {
    print(i)
}
import "C.eis"
import "A.eis"

//2 <= (5, 6, 7)
class X {
    public var x: int;
    public fn X() -> X {}
    public fn foo(x: const ref X, y: int) -> null {
        print(string(x.x + y))
    }
}

import "imported.wis"
var y = 6
val x = imported::X::X()
imported::X::foo(x, 5)
x.foo(y)
y = 5

for (var i = 0; i < 10000; ++i) {
    for (var j = 0; j < 10000; ++j) {
        var x = 1
        false or x or true
   }
}
//var x = 0
//var y : ref typeof x = x
//var z : typeof y = y
//y = z + 3

var x = 1
x += 1
x -= 1
x *= 20
x /= 20
//*/*/*/
fn go(n: int, acc: int) -> int {
    if (n > 1) {
        return go(n - 1, acc * n)
    } else {
        return acc
    }
}

fn factorial(n: int) -> int {
    return go(n, 1)
}

var x = int(readline("Enter a number: "))
print("The factorial of '" + string(x) + "' is: " + string(factorial(x)))

fn f(y: int) -> null {
    print(string(y) + '\n')
    var z: float = y
    print(string(z) + '\n')
    z = 5.6
    print(string(z) + '\n')
    z = 5
    print(string(z) + '\n')
}

var x: float = 5
print(string(x) + '\n')
f(x)

var x: [int, 5]
for (var i = 0; i < x.size; ++i) {
    x[i] = i
}
var y: [int] = x
fn f(z: [int]) -> null {
    for (var i = 0; i < z.size; ++i) {
        print(z[i])
    }
}

var x: [int, 10000]
for (var i = 0; i < 10000; ++i) {
    for (var j = 0; j < 10000; ++j) {
        x[i] = i + j
    }
}

var y: [int, 5]
fn fill(x: ref [int]) -> const ref [int] {
    for (var i = 0; i < 5; ++i) {
        x[i] = i
    }
    return x
}

var x: typeof(y) = fill(y)
x[1] = 200
print(string(y) + '\n' + string(x) + '\n')

fn foo(x: ref int) -> ref int {
    return x
}

var a = 0
var b: ref typeof(a) = foo(a)
b = 45
print(string(a) + '\n')

fn bar(x: [int, 20]) -> [int] {
    return x
}

print(string(bar(y)) + '\n')

var x = 0

class Foo {
    public var y: ref int = x
}

var foo = Foo()

class Bar {
    public var z: ref Foo = foo
}

fn baz(bar: const Bar) -> null {
    bar.z.y = 5
}

var x: [int, 4]
5 - 6 * 7, 8 + 9 - 45 / 5, 64 - 8 + 9 * 2, -5, 5 ? 6 : 7, x[5], x[5] = 6, x.size
var y = 0
y = 5

print(string('Hello world!\n' + string(5)))

fn foo(x: int) -> null {
    x = 5
}

class Foo {
    public var x: int = 0
    public fn fo() -> int {
        return 6;
    }
}

switch (1) {
    case 1: 5 * 67
    case 2: 6 * 65
}

class F {
    public var x: int = 0
    public var y = 0
}

var y:[int, 5]

var f = F()

var x = 0
x = 5, 6, f.x = 7, y[1] = 4

var x = 5 * 6
print(x)
for (var i = 0; i < 5; ++i) {
    if i == 4 {
        5 / 0
    }
}

var x: int
ref y = x
val z: typeof y = y
y = 7
print(string(x) + '\n')
fn f() -> null {
    x = 8
}
f()
var a = x
print(string(a) + '\n')

fn f() -> int {}
fn g() -> null {}
f()
g()
var i = 0
i++

print('This '
      'is '
      'a '
      'multiline '
      'string\n')
print('This
 is
 a
 multiline
 string
 too\n')
fn f(x: const ref [int]) -> null {
    print(x)
    print('\n')
}

fn g(x: const ref [string]) -> null {
    print(x)
    print('\n')
}

var x = [1, 5.0, 2, 3,]
val y : ref typeof x = x
var z = ['string1', 'string2', 'string3']
x = [2, 3, 4, 5]
f(x)
f(y)
g(z)
*/*/*/
fn printarr(y: [[int]]) -> null {
    for (var i = 0; i < size(y); ++i) {
        for (var j = 0; j < size(y[i]); ++j) {
            print(string(y[i][j]) + ' ')
        }
        print('\n')
    }
}
var x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
printarr(x)
x = [[10, 11, 12], [13, 14, 15], [16, 17, 18]]
printarr(x)
