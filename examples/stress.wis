/*/*/*
"This is a multiline\n
\t\b\b\b\b\\\\string"
// @#$

(5 + 6 - 4 + 3 * (5 - 6))
++(5 + 6)
x + 6



5 + 6



5, 6, 7
array.foo.sf(bar,
             baz,
             (quux[
             5]
             )

            )

x = 5
x += 5
x -= 5
x *= 5
x /= 5
x, y, z
x, y = 5, z = 6
x ? y : z
!!x
~~x
++x
--x
x.y.z = 5
x.y.z += 5
x.y.z -= 5
x.y.z *= 5
x.y.z /= 5
x.y.z, a.b.c, e.d.f
x.y.z ? a.b.c : e.d.f
!!x.y.z
~~x.y.z
++x.y.z
--x.y.z
x.y.z(5, 6, 7, arr[foo])

import foo
// */*/*/

var x: int = 5
val y: int = 5

fn bar(x: int, y: string) -> Foo {
    print("Hello world")
    return Foo(5)
}

// type Bar = Baz
class StructA {
    public var x: int
    public fn StructA() -> StructA {
        this.x = 5
    }
    public fn ~StructA() -> null {
    }
}

for (var i: int = 0; i < 5; ++i) {
    break
    continue
    print("hello world")
}

if 5 == 6 {
    print("How")
} else if 5 != 6 {
    print("Yes")
}

while x < 5 {
    print(x)
    ++x
}

switch (x) {
    case 5: {
        print(x)
        break
    }
    case 6: {
        print(x + 1)
        break
    }
    default: {
        print("Default case")
        break
    }
}

fn foo(x: int) -> int {
    return x
}

for (var i: int = 0; i < 5; ++i) {
    break
    continue
}

 
{
    print("Hello world");
}

// break
// class F }
// fn bar(x:) -> }
var goo = 4;
switch (goo) {
    case goo: break
}
// */*/*/

import "../examples/imported.eis"

class Bar {
    public var x: int
}

class Foo {
    public var y: Bar

    public fn xi(z: int) -> int {
        return this.y.x * z
    }

    public fn Foo(x: int) -> Foo {
        var new: Foo
        return new
    }
}

fn test() -> [int] {
    var x: [int]
    return x
}

var y = 0.5
test2(y)
fn test2(x: int) -> int {
    var y: const ref int = x
    return y
}

var foo = Foo(5)
var z: [[int, foo], 5]
var zzy: int = 5, 6,
z[0][0]

var yay = imported::X()
print(yay.x)
print(imported::foo())

import "imported.eis"

var y = imported::X()
y.x = 6

for (var i = 0; i < 5; ++i) {
    print(i)
}
import "C.eis"
import "A.eis"

//2 <= (5, 6, 7)
class X {
    public var x: int;
    public fn X() -> X {}
    public fn foo(x: const ref X, y: int) -> null {
        print(string(x.x + y))
    }
}

import "imported.wis"
var y = 6
val x = imported::X::X()
imported::X::foo(x, 5)
x.foo(y)
y = 5
*/*/*/
5 / 0